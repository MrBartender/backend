#####
# Access details for an object in S3
#
type S3Object {
  bucket: String!
  key: String!
  access: AccessLevel!
}

#####
# Access level of an S3 Object
#
enum AccessLevel { public private }

#####
# Collection of images for an object
#
type ProfilePic
{
  icon: S3Object
  small: S3Object
  large: S3Object
  banner: S3Object
}

#####
# Vendor that owns bartenders
#
type Vendor @model @searchable
{
  id: ID!
  semanticId: String!
  name: String!
  website: AWSURL
  profilePic: ProfilePic
  currentUsers: [User!]! @connection(name: "VendorUsers")
  collections: [Collection!] @connection(name: "VendorCollections")
  devices: [Device!]! @connection(name: "VendorDevices")
  orders: [Order!]! @connection(name: "VendorOrders")
}

#####
# Organized collection of drinks at a vendor
#
type Collection @model @searchable
{
  id: ID!
  name: String!
  drinks: [Recipe!]! @connection
  vendor: Vendor @connection(name: "VendorCollections")
}

#####
# User rating of a recipe
#
type Rating @model
{
  id: ID!
  reviewer: User! @connection(name: "UserReviews")
  recipe: Recipe! @connection(name: "RecipeReviews")
  score: Int!
  comment: String
}

#####
# Piece of a recipe
#
type Component
{
  ingredient: Ingredient!
  product: Product
  ratio: Float!
}

#####
# Recipe of a drink
#
type Recipe @model @searchable
{
  id: ID!
  name: String!
  price: Int!
  description: String
  instructions: String
  profilePic: ProfilePic!
  components: [Component!]!
  reviews: [Rating!]! @connection(name: "RecipeReviews")
  orders: [Order!]! @connection(name: "OrderRecipe")
}

#####
# Actual product (e.g. Absolut Vodka Pineapple 750ml)
#
type Product @model @searchable
{
  id: ID!
  name: String!
  ingredient: Ingredient! @connection(name: "IngredientProducts")
  proof: Int!
  volume: Int!
}

#####
# Ingredient class (e.g. gin, vodka, OJ)
#
type Ingredient @model @searchable
{
  id: ID!
  name: String!
  alcoholic: Boolean!
  products: [Product!]! @connection(name: "IngredientProducts")
}

#####
# Calibration equation for a type of pumps
#
type Calibration
{
  formula: String
}

#####
# Calibration weights for a single pump
#
type Weights
{
  weights: [Float!]
}

#####
# Automated pouring machine registered with a vendor
#
type Device @model @searchable
  @auth(rules: [
      { allow:owner },
      { allow:groups, groups:["Consumers"], queries:[get, list] }
    ])
{
  id: ID!
  status: DeviceStatus!
  name: String!
  semantic_id: String!
  pourCode: String
  vendor: Vendor! @connection(name: "VendorDevices")
  calibration: Calibration!
  pumps: [Pump!]! @connection
  orders: [Order!]! @connection(name: "DeviceOrders")
  availableRecipes: Collection! @connection
}

#####
# Pump Object on a device
#
type Pump @model
{
  id: ID!
  semantic_id: Int!
  status: PumpStatus!
  product: Product @connection
  costByVolume: Int
  volumeLeft: Int!
  calibration: Weights!
}


#####
# Status of a pump
#
enum PumpStatus
{
  active
  inactive
}

#####
# Public status of each device
#
enum DeviceStatus
{
  active
  inactive
  maintance
  error
}

#####
#  User data
#
type User @model
  @auth(rules: [{ allow:owner }])
{
  id: ID!
  name: String!
  currentVendor: Vendor @connection(name: "VendorUsers")
  previousVendors: [Vendor!] @connection
  orders: [Order!]! @connection(name: "UserOrders")
  reviews: [Rating!]! @connection(name: "UserReviews")
}

#####
# Timestamps for an order
#
type Timestamps {
  ordered: AWSTimestamp
  paid: AWSTimestamp
  poured: AWSTimestamp
}

#####
# Order object created by a user
#
type Order @model
  @auth(rules: [{ allow:owner }])
{
  id: ID!
  status: OrderStatus!
  price: Int!
  cost: Int!
  consumer: User! @connection(name: "UserOrders")
  recipe: Recipe! @connection(name: "OrderRecipe")
  device: Device! @connection(name: "DeviceOrders")
  vendor: Vendor! @connection(name: "VendorOrders")
  timestamps: Timestamps!
}

#####
# Status of a placed order
#
enum OrderStatus
{
  pending
  pouring
  poured
  suspended
  cancelled
  refund_requested
  refunded
}